Basic Computer Organization
- The CPU(stands for Central Processing Unit) (also reffered to as the processor or microprocessor)
- Working memory (usually reffered to as RAM(stands for Random Access Memory))
- Permanent storage (HDD, SSD, USB sticks and etc.)
- Peripherals (everything else)
- System bus (everything that is connected to the CPU conencts through a BUS, or SYSTEM BUS)

The common conceptual parts of a CPU are:
- Registers
- Control unit
- Arithmetic and logic unit
- Memory management unit
- Caches

Registers - tiny blocks of memory inside the processor itself. These are bits of data that the processor can access
directly without waiting. Essentially what happens is that programs load data from memory into the registers, then process
the data in the registers using various instructions, and then write the contents of those registers back out to memory.

The Control Unit - sets the pacing for the chip. It handles the coordination of all the different parts of the chip. It handles
the clock, which doesn't tell time, but is more like a drum beat of a pacemaker - it makes sure that everything operates at the
same speed.

the Arithmetic and Logic Unit (ALU) - where proccessing takes place. It does the additions, subtractions, comparisons, etc.
the ALU is normally wired so that basic operations can be done with registers extremly quickly (typically in a single clock cycle).

the Memory Management Unit - in a simple fashion, it manages the way that the processor sees and understands memory addresses.

Caches - A cache is a piece of memory that holds other memory closer to the CPU. For instance, instructions are usually carried
out in the same order that they are stored in memory. Therefore, rather than wait for the control unit to request the next instruction
and then wait for the instruction to arrive from main memory, the CPU can preload a segment of memory that it thinks will be
useful into a cache. That way, when the CPU asks for the next instruction, it doesn’t have to wait on the system bus to deliver
the instruction from memory - it can just read it directly from the cache. CPUs implement all sorts of caches, each of which cache
different things for different reasons, and even have different access speeds.


The Fetch-Execute Cycle - the way that the processor runs programms is through the fetch-execute cycle. The computer operates
by reading your program one instruction at a time. It knows which instruction to read through a special register known as
the Instruction Pointer (or IP), which is also known as the Program Counter (or PC).
The computer essentially runs an endless cycle of the following operations:
- Read the instruction form the memory address specified by the instruction pointer.
- Decode the instruction (i.e., figure out what the instruction means).
- Advance the instruction pointer to the next instruction.
- Perform the operation indicated by the instruction.
Each instruction is extremely limited in its operation. Available instructions do operations like the following:
- Load a value from memory into a register.
- Store a value from a register into memory.
- Do a single arithmetic operation.
- Compare two values.
- Go to a different location in the code (i.e., modify the instruction pointer) based on the result of a 
previous comparison.


The General-Purpose Registers
The x86-64 ISA has 16 general-purpose registers. In the general case, you can specify these
registers for the source or destination of many different instructions. Eight of those are
carried over from the 32-bit architecture. These eight are divided into two classes.
The first class of registers are four registers that we might call the computational
registers. These registers are %rax, %rbx, %rcx, and %rdx.
These registers are normally used for general computation. Additionally, the ability to access
individual bytes of the registers can come in handy, as a lot of data is organized around individual bytes.
For instance, %rbx has a 32-bit version called %ebx
embedded in it, which has the original %bx embedded in that, whose individual high and
low bytes can be referred to by %bh and %bl.

%rax: This is the accumulator. It is the most widely used general-­
purpose register for computation.

%rbx: This is known as the "base register." This is often used for
indexed addressing.

%rcx: This is known as the "counter register." It is historically used
for counts when doing repetitive code (loops).

%rdx: This is known as the "data register." It has some special
significance in certain arithmetic operations and input/output
operations and is also sometimes used in some instructions in
coordination with %rax, such as with the divq instruction.

The next four registers are still considered "general purpose" because they can be
used in computation, but they are actually focused on specific tasks. The first two (%rsi
and %rdi) can be safely for general purposes, but it is best to leave the others for their
special purpose. Note that, while each of these has a 32-bit and 16-bit version, you
cannot access any individual bytes in these registers. For instance, the %rdi register has
a 32-bit version (%edi) and a 16-bit version (%di), but there is no register that will give
me any individual bytes from this register.

%rsi: This is the "source index" register. It has special uses for
working with longer spans of memory.

%rdi: This is the "destination index" register. It is often used in
conjunction with %rsi for working with longer spans of memory.

%rbp: This is the "base pointer."

%rsp: This is the "stack pointer."

Finally, while the previous registers can trace their history back to the original 8086
chip that started it all, the x86-64 ISA gives us eight new general-purpose registers. These
are simply labeled as %r8 through %r15.
Even though these registers didn’t exist in previous versions of the ISA, these
registers also have 32-bit, 16-bit, and individual-byte versions. For instance, %r11 refers
to the whole 64-bit version of the register. However, you can refer to the 32-bit version by
specifying %r11d, the 16-bit version by specifying %r11w, and the least significant (low)
byte by specifying %r11b. Each of the new general-purpose registers can be accessed in
this way.


Some registers have a specific function that is maintained by the CPU itself.
These are the special-purpose registers.

%rip - Instruction Pointer. The instruction pointer simply points to the next memory location that the
processor is going to process an instruction from. This lets the CPU know where to pull
the next instruction from when the next clock cycle runs. During each instruction, the
CPU will increment the instruction pointer to point to the next instruction—the one
immediately after the current instruction. This register can be manipulated through jump instructions.
A jump instruction tells the computer to alter the flow of the program by setting the instruction pointer to a value
that is different from where the CPU was going to set it to. The most basic form of this
instruction is simply jmp, which tells the processor the address of the next instruction
you want to execute.

%eflags - special-purpose register (conditions for jump instructions)
Rather than thinking about %eflags as holding a single value, you usually think
about the different bits of %eflags separately. Each bit holds a true/false status of a
previous operation. Most of the bits of the %eflags register are for operating system usage and aren’t of
extreme concern to us. However, there are two flags that come in useful continually:
ZF: The zero flag is set to 1 if the result of the last arithmetic
operation was zero, or 0 if it was not.
CF: The carry flag is set to 1 if the result of the last arithmetic
operation resulted in a “carry”—that is, the result was bigger than
could be held in the destination register.
What happens is that at the end of each arithmetic instruction (instructions like
addX, mulX, but not movX), the processor sets the value of these status bits in the %eflags
register. The typical way to make use of these flags is with a conditional jump statement. A
conditional jump statement will jump based on the configuration of particular flags. If
the condition matches, the jump will occur. Otherwise, the processor will just go to the
next instruction as if nothing happened. Common jump instructions include
jz: “Jump if Zero” (jump if the zero flag is set to 1).
jnz: “Jump if Not Zero” (jump if the zero flag is set to 0).
jc: “Jump if Carry” (jump if the carry flag is set to 1).
jnc: “Jump if No Carry” (jump if the carry flag is set to 0).
